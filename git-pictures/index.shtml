<!--#set var="title" value="Git in Pictures" -->
<!--#set var="extra-css" value="
IMG {
	border: 1px solid #444;
}
H2 SPAN,
H3 SPAN,
H4 SPAN {
	color: #AAA;
}
" -->
<!--#include file="/assets/header.shtml" -->
<!--#include file="/assets/navbar.html" -->

<div class="container">
	<div class="page-header">
		<h1>Git in Pictures</h1>
	</div>
	<div class="row">
		<div class="span12">

<h2>Yet Another Git Tutorial</h2>

<p>Explaining what happens behind the scenes, because it's all remarkably sensible; it's just totally different to what most people are used to:

<ul>
<li><a href="#begin">Basics</a>
<li><a href="#amend">Basic History Tweaking: Amending Commits</a>
<li><a href="#pick-rebase">Advanced History Tweaking: Cherry-Pick and Rebase</a>
<li><a href="#network">Centralised Networking</a>
<li><a href="#distributed">Distributed Networking</a>
</ul>

<section id="begin">
	<h2>The Basics</h2>

	<h3>Initial State</h3>
	<img src="01_initial_state.svg">
	<p>For the sake of getting started quickly, let's work with an already created repository. This one has two commits ("first commit" and "second commit"), one branch ("master", which is a reference to the second commit), and the currently active branch (aka HEAD) is set to the master.
	<p>Something that may jump out in that image is the commits having hex codes above them. These codes are the commit's unique ID, which is generated by <code>sha1(parent ID + current commit details)</code>. Because each commit ID is its parent and its details, and its parent's ID is in turn based on its own parent and details, this means that a commit ID is a hash of all history up to that point. 
	<p>One of the most common things to do with a repository is commit some new work:

	<h3>Commit <span>git commit -a -m "a new commit"</span></h3>
	<img src="02_commit.svg">
	<p>After the commit command is run, there is a new commit object - this commit has recorded the current state of the files, along with the commit that the work was based on.
	<p>As well as adding the commit, the command has also updated our currently active branch pointer ("master") to point to the new commit. This is how branches work in git -- whenever you add a commit, the currently active reference will be updated to point to it.
	<p>Sometimes it's useful to keep a note of a specific commit, and you don't want the reference to change. For that, there is a different type of reference, called a tag:

	<h3>Tag <span>git tag v1.0.0</span></h3>
	<img src="03_tag.svg">
	<p>A "tag" reference is very similar to a "branch" reference -- they are both simply files (in .git/refs) which contain a 40-character commit ID. The only difference is that branches will be updated whenever a commit is added, and tags will stay where they are.
	<p>Speaking of branches, let's create a new branch so that we can work on a feature:

	<h3>Branch <span>git branch my-feature</span></h3>
	<img src="04_branch.svg">
	<p>Here we've created a new branch. It's just a new reference to the current commit (a new 40-character file in .git/refs, if you fancy poking around the internals).
	<p>Since we've created the branch, let's try using it. First, make the branch active:

	<h3>Checkout <span>git checkout my-feature</span></h3>
	<img src="05_checkout.svg">
	<p>The checkout command will switch the active branch (ie, it will switch what HEAD points to). It will also update the files in your working directory, if the files there are different to those in the named branch.
	<p>Let's do some work on that feature, and commit it:

	<h3>Commit <span>git commit -a -m "my-feature commit"</span></h3>
	<img src="06_commit.svg">
	<p>Here we can see that the new commit was added, the "my-feature" branch has moved on, but "master" and "v1.0.0" are still where they were to start with.
	<p>But oh no! A bug has been spotted in master! Let's switch back:

	<h3>Checkout <span>git checkout master</span></h3>
	<img src="07_checkout.svg">
	<p>Do some work, and commit the fix:

	<h3>Commit <span>git commit -a -m "fixing a bug"</span></h3>
	<img src="08_commit.svg">
	<p>Now that master has moved on too, our feature and master branches are starting to look like real branches.
	<p>With the bug fixed, let's get back to the feature.

	<h3>Checkout <span>git checkout my-feature</span></h3>
	<img src="09_checkout.svg">
	<p>And then finish it off:

	<h3>Commit <span>git commit -a -m "finish the feature"</span></h3>
	<img src="10_commit.svg">
	<p>Now that the feature is finished, we can merge the branch. First, switch to the branch where you want the merge to happen:

	<h3>Checkout <span>git checkout master</span></h3>
	<img src="11_checkout.svg">
	<p>Then merge:

	<h3>Merge <span>git merge my-feature</span></h3>
	<img src="12_merge.svg">
	<p>Now a new commit is created, with two parents. Since we added a new commit while "master" was active, the master reference has been updated to point to the new commit.
	<p>All done with that branch? Then it can be deleted:

	<h3>Branch delete <span>git branch -d my-feature</span></h3>
	<img src="13_branch_delete.svg">
	<p>Much like the creation of the branch is simply creating a new reference, the deletion is simply deleting a reference. All the commits that were in that branch are still on disk -- they live on as part of master's history.
	<p>And then we can carry on as normal

	<h3>Commit <span>git commit -a -m "carry on working"</span></h3>
	<img src="14_commit.svg">
</section>

<section id="amend">
	<h2>Amend</h2>
	<p>Sometimes everything seems fine until just after hitting the "Commit" button. Thankfully, git allows tweaking local history and nobody has to know (rewriting public history is likely to cause problems, but there are safeguards against that).

	<p>Let's say you have a simple repository:
	<p><img src="amend/01_initial_state.svg">
	<p>And then make a commit:
	
	<h3>Commit <span>git commit -a -m "did some wrok"</span></h3>
	<p><img src="amend/02_commit_1.svg">
	<p>But oh no, a typo! We don't want people to see that, so we can make a new commit, which will basically be the same as the old commit, but slightly tweaked. In this case we're only tweaking the commit message, but it's also possible to change files and amend those too.

	<h3>Commit (Amend) <span>git commit --amend -a -m "did some work"</span></h3>
	<p><img src="amend/03_commit_2.svg">
	<p>Note that the original commit still exists, there just aren't any references to it; it'll hang around for a couple of weeks until it gets garbage collected (so for example if the amend wasn't intentional, you can go back to the original version of the commit and work on top of that instead)
	
</section>

<section id="pick-rebase">
	<h2>Cherry-pick / rebase</h2>
	<p>Because you don't always want to merge an entire branch -- sometimes there are individual commits that fix things, but the rest of the branch is working on a large feature that isn't ready yet

	<h3>Initial State <span></span></h3>
	<img src="20_initial_state.svg">
	<p>Here we see that somebody's been doing some work in their own branch; but some of the things would be useful to have in master.
	<p>So, let's go there:

	<h3>Checkout <span>git checkout master</span></h3>
	<img src="21_checkout.svg">
	<p>Now that we're in master, we can pull individual commits from other branches. Let's start with the big fix.

	<h3>Cherry-Pick <span>git cherry-pick 038cab34</span></h3>
	<img src="22_cherrypick.svg">
	<p>That went well. Note that the new commit has a different commit ID - despite the change itself being the same, it is based on different history. Let's have the small one as well:

	<h3>Cherry-Pick <span>git cherry-pick 32760934</span></h3>
	<img src="23_cherrypick.svg">
	<p>With those in master, we can get back to work in our feature branch:

	<h3>Checkout <span>git checkout feature</span></h3>
	<img src="24_checkout.svg">
	<p>While merging at this point would be fine, there is an opportunity to make things a little cleaner -- rather than having the branch based on an old master with bugfix commits duplicated, we can use the rebase command to move the branch on top of the latest master:

	<h3>Rebase <span>git rebase master</span></h3>
	<img src="25_rebase.svg">
	<p>Since git knows that "fix a major bug" and "fix a small bug" are already in the project history, it doesn't need to re-add them; the commits that introduce new work are kept, while the bugfixes aren't duplicated.
	<p>All the original commits are still there, but will be garbage collected when the GC runs, because there is nothing pointing at them.
</section>

<section id="network">
	<h2>Networked version control</h2>
	<p>Remember how a commit ID is the hash of the whole project history up to that point? This makes it easy for multiple people to compare histories, because no matter where or when you are, the same ID will always refer to the same data. If your "master" is pointing to "abc123", and origin's "master" is pointing to "def456, which has a parent of abc123", then you know that someone else has made one commit that you haven't seen.
	<p>Most of the time, you'll want to be working with a remote repository, like this one:
	<p><img src="30_origin.svg">

	<h3>Clone <span>git clone git://github.com/user/repo.git</span></h3>
	<img src="31_clone.svg">
	<p>Clone makes a copy of a remote repository, then renames the fetched references to <code>origin/$name</code>.
	It also gives you your own <code>master</code> branch to work on.
	<p>Let's assume that somebody has added some new commits to origin:
	<p><img src="32_remote_work.svg">
	
	<p>So, how do we see them?

	<h3>Pull <span>git pull</span></h3>
	<p>Pull does two things -- first it downloads the remote commits and remote references (<code>git fetch</code>), then it makes sure that the remote changes are merged with your local changes (<code>git merge</code>). Let's look at these individually:

	<h4>Fetch <span>git fetch origin</span></h4>
	<p><img src="33_fetch.svg">
	<p>See how the tree of history has been updated so that the commits all match up, and the remote branches "feature" and "master" match "origin/feature" and "origin/master" locally. Our currently active code (the "master" that HEAD points to) is still lagging behind though; so on to pull part 2:

	<h4>Merge <span>git merge origin/master</span></h4>
	<p>Since the local copy of master hasn't had any changes, then this so-called "merge" simply consists of fast-forwarding our local "master" to catch up with "origin/master"
	<p><img src="34_merge.svg">
</section>

<section id="distributed">
	<h2>Distributed version control</h2>
	<p>The above pattern, with developers speaking to a central "origin" repository is generally the most common approach for small, tight-knit groups. But for large projects with teams all over the world, you don't need to be limited to a single origin server. Let's say that starting with the basic repository, two separate teams decided to work on different features. One team in France added a waffle, and another team in Germany added a kitten:
	<p><img src="distributed/01_initial_state.svg">
	<p>But here in England, our project spec demands a waffle <b>and</b> a kitten!
	<p>First things first, let's let git know that those other teams exist (this only needs doing once):
	<p><code>git remote add france ssh://dev.mycompany.fr/le-repos/project1.git</code>
	<p><code>git remote add germany ssh://dev.mycompany.de/das-repos/project1.git</code>
	<p>Then we fetch the work of the French team:

	<h4>Fetch <span>git fetch france</span></h4>
	<p><img src="distributed/02_fetch_france.svg">
	<p>And the German team:

	<h4>Fetch <span>git fetch germany</span></h4>
	<p><img src="distributed/03_fetch_germany.svg">
	<p>Now that we've collected all the different commits in one place, we can merge both branches into our own master:

	<h4>Merge <span>git merge france/master germany/master</span></h4>
	<p><img src="distributed/04_merge.svg">
</section>

		</div>
	</div>

<!--#include file="/assets/footer.html" -->
