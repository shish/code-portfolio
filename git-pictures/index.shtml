<!--#set var="title" value="Git in Pictures" -->
<!--#set var="extra-css" value="
IMG {
	border: 1px solid #444;
}
H3 SPAN {
	color: #AAA;
}
" -->
<!--#include file="/assets/header.shtml" -->
<!--#include file="/assets/navbar.html" -->

<div class="container">
	<div class="page-header">
		<h1>Git in Pictures</h1>
	</div>
	<div class="row">
		<div class="span12">

<h2>Yet Another Git Tutorial</h2>

<section id="begin">
	<h2>The Basics</h2>

	<h3>Initial State</h3>
	<img src="01_initial_state.svg">
	<p>For the sake of getting started quickly, let's work with an already created repository. This one has two commits ("first commit" and "second commit"), one branch ("master", which is a reference to the second commit), and the currently active branch (aka HEAD) is set to the master.
	<p>Something that may jump out in that image is the commits having hex codes above them. These codes are the commit's unique ID, which is generated by <code>sha1(parent ID + current commit details)</code>. Because each commit ID is its parent and its details, and its parent's ID is in turn based on its own parent and details, this means that a commit ID is a hash of all history up to that point. 
	<p>One of the most common things to do with a repository is commit some new work:

	<h3>Commit <span>git commit -a -m "a new commit"</span></h3>
	<img src="02_commit.svg">
	<p>After the commit command is run, there is a new commit object - this commit has recorded the current state of the files, along with the commit that the work was based on.
	<p>As well as adding the commit, the command has also updated our currently active branch pointer ("master") to point to the new commit. This is how branches work in git -- whenever you add a commit, the currently active reference will be updated to point to it.
	<p>Sometimes it's useful to keep a note of a specific commit, and you don't want the reference to change. For that, there is a different type of reference, called a tag:

	<h3>Tag <span>git tag v1.0.0</span></h3>
	<img src="03_tag.svg">
	<p>A "tag" reference is very similar to a "branch" reference -- they are both simply files (in .git/refs) which contain a 40-character commit ID. The only difference is that branches will be updated whenever a commit is added, and tags will stay where they are.
	<p>Speaking of branches, let's create a new branch so that we can work on a feature:

	<h3>Branch <span>git branch my-feature</span></h3>
	<img src="04_branch.svg">
	<p>Here we've created a new branch. It's just a new reference to the current commit (a new 40-character file in .git/refs, if you fancy poking around the internals).
	<p>Since we've created the branch, let's try using it. First, make the branch active:

	<h3>Checkout <span>git checkout my-feature</span></h3>
	<img src="05_checkout.svg">
	<p>The checkout command will switch the active branch (ie, it will switch what HEAD points to). It will also update the files in your working directory, if the files there are different to those in the named branch.
	<p>Let's do some work on that feature, and commit it:

	<h3>Commit <span>git commit -a -m "my-feature commit"</span></h3>
	<img src="06_commit.svg">
	<p>Here we can see that the new commit was added, the "my-feature" branch has moved on, but "master" and "v1.0.0" are still where they were to start with.
	<p>But oh no! A bug has been spotted in master! Let's switch back:

	<h3>Checkout <span>git checkout master</span></h3>
	<img src="07_checkout.svg">
	<p>Do some work, and commit the fix:

	<h3>Commit <span>git commit -a -m "fixing a bug"</span></h3>
	<img src="08_commit.svg">
	<p>Now that master has moved on too, our feature and master branches are starting to look like real branches.
	<p>With the bug fixed, let's get back to the feature.

	<h3>Checkout <span>git checkout my-feature</span></h3>
	<img src="09_checkout.svg">
	<p>And then finish it off:

	<h3>Commit <span>git commit -a -m "finish the feature"</span></h3>
	<img src="10_commit.svg">
	<p>Now that the feature is finished, we can merge the branch. First, switch to the branch where you want the merge to happen:

	<h3>Checkout <span>git checkout master</span></h3>
	<img src="11_checkout.svg">
	<p>Then merge:

	<h3>Merge <span>git merge my-feature</span></h3>
	<img src="12_merge.svg">
	<p>Now a new commit is created, with two parents. Since we added a new commit while "master" was active, the master reference has been updated to point to the new commit.
	<p>All done with that branch? Then it can be deleted:

	<h3>Branch delete <span>git branch -d my-feature</span></h3>
	<img src="13_branch_delete.svg">
	<p>Much like the creation of the branch is simply creating a new reference, the deletion is simply deleting a reference. All the commits that were in that branch are still on disk -- they live on as part of master's history.
	<p>And then we can carry on as normal

	<h3>Commit <span>git commit -a -m "carry on working"</span></h3>
	<img src="14_commit.svg">
</section>

<section id="pick-rebase">
	<h2>Cherry-pick / rebase</h2>
	<p>Because you don't always want to merge an entire branch -- sometimes there are individual commits that fix things, but the rest of the branch is working on a large feature that isn't ready yet

	<h3>Initial State <span></span></h3>
	<img src="20_initial_state.svg">
	<p>Here we see that somebody's been doing some work in their own branch; but some of the things would be useful to have in master.
	<p>So, let's go there:

	<h3>Checkout <span>git checkout master</span></h3>
	<img src="21_checkout.svg">
	<p>Now that we're in master, we can pull individual commits from other branches. Let's start with the big fix.

	<h3>Cherry-Pick <span>git cherry-pick 038cab34</span></h3>
	<img src="22_cherrypick.svg">
	<p>That went well, let's have the small one as well:

	<h3>Cherry-Pick <span>git cherry-pick 32760934</span></h3>
	<img src="23_cherrypick.svg">
	<p>With those in master, we can get back to work in our feature branch:

	<h3>Checkout <span>git checkout feature</span></h3>
	<img src="24_checkout.svg">
	<p>While merging at this point would be fine, there is an opportunity to make things a little cleaner -- rather than having the branch based on an old master with bugfix commits duplicated, we can use the rebase command to move the branch on top of the latest master:

	<h3>Rebase <span>git rebase master</span></h3>
	<img src="25_rebase.svg">
	<p>Since git knows that "fix a major bug" and "fix a small bug" are already in the project history, it doesn't need to re-add them; the commits that introduce new work are kept, while the bugfixes aren't duplicated.
	<p>All the original commits are still there, but will be garbage collected when the GC runs, because there is nothing pointing at them.
</section>

<section id="network">
	<h2>Distributed Version Control</h2>
	<p>Most of the time, you'll want to be working with a remote repository

	<h3>Clone <span>git clone git://github.com/user/repo.git</span></h3>
	<p>Clone makes a copy of a remote repository, then renames the fetched references to <code>origin/$name</code>
	<p>Let's assume that somebody has added some new commits to origin:
	
	<p>So, how do we see them?

	<h3>Fetch</h3>
	<p>Remember how a commit ID is the hash of the whole project history up to that point? This makes it easy for multiple people to compare histories, because no matter where or when you are, the same ID will always refer to the same data.
	<p>When you pull, git will <code>fetch</code> the remote references, and then fetch any commits (along with their histories) that those references point to.

	<h3>Merge</h3>

</section>

		</div>
	</div>

<!--#include file="/assets/footer.html" -->
